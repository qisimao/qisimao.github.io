<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>CocoaYang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="CocoaYang">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="CocoaYang">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CocoaYang">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="CocoaYang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">CocoaYang</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-银联支付" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/21/银联支付/" class="article-date">
  <time datetime="2015-12-21T00:53:31.000Z" itemprop="datePublished">2015-12-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/21/银联支付/">银联支付</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>下载地址：<br><a href="https://open.unionpay.com/upload/download/Development_kit85427986.rar" target="_blank" rel="external">https://open.unionpay.com/upload/download/Development_kit85427986.rar</a><br>其实我找了半个小时 也不知道怎么就下载好了 这个我在Chrome的下载记录里找到的</p>
<p>解压之后会有这样的目录结构</p>
<p><img src="http://ac-1qdtcf4c.clouddn.com/1e0622f04f4be6e0.png" alt=""></p>
<p>文档在下面 sdk在upmp_iPhone里面</p>
<p><img src="http://ac-1qdtcf4c.clouddn.com/8b5f547a680472aa.png" alt=""></p>
<p>1、SDK 说明</p>
<p>SDK 分为以下两个版本:<br>1.支持纯无卡交易静态库,以下简称 UPPayPlugin,包含文件:</p>
<p>UPPayPlugin.h  UPPayPluginDelegate.h  libUPPayPlugin.a</p>
<p>2、支持纯无卡交易和 VIPOS 音频口支付静态库,以下简称 UPPayPluginPro,</p>
<p>包含文件:</p>
<p>UPPayPluginPro.h<br>UPPayPluginDelegate.h  libUPPayPluginPro.a<br>3、添加 SDK 包</p>
<p>a.根据商户选择的SDK版本,将sdk/inc目录和sdk/libs目录下对应版本的三个文件添加到 UPPayDemo 工程中;</p>
<p>b.如 果 你 选 择 的 是 UPPayPlugin 版 本 , 添 加 QuartzCore.framework 、Security.framework 到工程中;</p>
<p>c.如 果 你 选 择 的 是 UPPayPluginPro 版 本 , 添 加 QuartzCore.framework 、AudioToolbox.framework, CoreAudio.framework 、 MediaPlayer.framework,AVFoundation.framework 和 Security.framework 到工程中;</p>
<p>d.在工程的 Build Settings 中找到 Other Linker Flags 中添加-ObjC 宏;（这个可能是遗留的问题 我就没写 不报错）</p>
<p><img src="http://ac-1qdtcf4c.clouddn.com/25c11e0c7ae2466b.png" alt=""></p>
<p>4、调用插件</p>
<p>a.在需要调用支付控件的源文件内引用头文件 UPPayPlugin.h 或 UPPayPluginPro.h(注意:如果工程的 compile source as 选项的值不是 Objective–C++,则引用此头文件的文件类型都要改为.mm)</p>
<p>b.通过调用</p>
<p>(BOOL)startPay:(NSString)tn mode:(NSString)mode</p>
<p>viewController:(UIViewController*)viewController delegate:(id)delegate;</p>
<p>实现控件的调用</p>
<p>c.处理支付结果</p>
<p>银联手机支付控件有三个支付状态返回值:success、fail、cancel,分别代表:支付成功、支付失败、用户取消支付。这三个返回状态值以字符串的形式作为回调函数参数(NSString)result 返回。通过在工程中添加头文件“UPPayPluginDelegate.h”,在处理交易结果的界面,实现 UPPayPluginDelegate接口,根据该头文件中的回调函数:-(void)UPPayPluginResult:(NSString)result来实现回调方法,从而可以根据支付结果的不同进行相关的处理。</p>
<p>a.将 xcode 工程中 Build Setting -&gt; Apple LLVM compiler Language 标签下的 C++ Language Dialect 和 C++ Standard Library 属性值修改为 Compiler Default</p>
<p>b.将涉及到引用 UPPayPlugin.h 的源文件的后缀名都改为.mm;</p>
<p>c.参照demo，检查工程设置 Search Paths 里的 Framework Search Paths、Header Search Paths、Library Search Paths 的路径设置,看设置路径是否正确</p>
<p>d.添加 QuartzCore.framework、AudioToolbox.framework, CoreAudio.framework、 MediaPlayer.framework, AVFoundation.framework 和 Security.framework</p>
<p>e.工程的 Build Settings 中找到 Other Linker Flags 中添加-ObjC 宏;</p>
<p>上面提到的几点网上都可以找到，如果已经正确设置，还是编译不通过，那么赶紧检查下 项目targets 对应的sdk版本，选择7.0以下的，目前银联的sdk貌似还不支持7.0，</p>
<p>注：</p>
<p>银联支付目测只需要2个参数 1 tn 其实就是订单号 2 mode 是测试环境还是线上环境</p>
<p>和支付宝不同的是 支付宝要求本地把订单的信息书写完毕 调起sdk支付即可 银联是我把一些生成订单的信息 如 付款方 收款方 订单描述 金额等信息传递到服务器 由服务器生成一个订单号 然后客户端调起sdk进入支付</p>
<p>mode 竟然是个死的字符串 真是醉了 “00” 表示线上环境”01”表示测试环境</p>
<p>返回的代理结果 更是坑爹 :success、fail、cancel,分别代表:支付成功、支付失败、用户取消支付</p>
<p>测试环境 账号</p>
<p>提供测试使用卡号、手机号信息(此类信息仅供测试,不会发生正式交易)招商银行预付费卡:卡号:6226 4401 2345 6785密码:111101</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/21/银联支付/" data-id="cijmj82jb0000nj0enn88b5k6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-微信支付" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/21/微信支付/" class="article-date">
  <time datetime="2015-12-21T00:52:32.000Z" itemprop="datePublished">2015-12-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/21/微信支付/">微信支付</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>微信支付场景介绍：</p>
<p>适用于商户在移动端APP中集成微信支付功能。</p>
<p>商户APP调用微信提供的SDK调用微信支付模块，商户APP会跳转到微信中完成支付，支付完后跳回到商户APP内，最后展示支付结果。</p>
<p>目前微信支付支持手机系统有：IOS（苹果）、Android（安卓）和WP（Windows Phone）。<br>交互细节如下：</p>
<p>步骤1：用户进入商户APP，选择商品下单、确认购买，进入支付环节。商户服务后台生成支付订单，签名后将数据传输到APP端。以微信提供的DEMO为例。<br><img src="" alt=""></p>
<p>步骤2：用户点击后发起支付操作，进入到微信界面，调起微信支付，出现确认支付界面，见图8.2。</p>
<p><img src="http://ac-1qdtcf4c.clouddn.com/a8e0a86de05d7e0f.jpg" alt=""></p>
<p>步骤3：用户确认收款方和金额，点击立即支付后出现输入密码界面，可选择零钱或银行卡支付见图8.3。</p>
<p><img src="http://ac-1qdtcf4c.clouddn.com/061ea314f7baa63a.jpg" alt=""></p>
<p>第四步：输入正确密码后，支付完成，用户端微信出现支付详情页面。</p>
<p><img src="http://ac-1qdtcf4c.clouddn.com/7f6a9eec5845afa5.jpg" alt=""></p>
<p>第五步：回跳到商户APP中，商户APP根据支付结果个性化展示订单处理结果。</p>
<p><img src="http://ac-1qdtcf4c.clouddn.com/1e98e812bde76cf4.jpg" alt=""></p>
<p>##案例介绍<br>以下是交互时序图，统一下单API、支付结果通知API和查询订单API等都涉及签名过程，调用都必须在商户服务器端完成。<br><img src="http://ac-1qdtcf4c.clouddn.com/238088fa0b3901fa.png" alt=""></p>
<p>商户系统和微信支付系统主要交互说明：<br>步骤1：用户在商户APP中选择商品，提交订单，选择微信支付。<br>步骤2：商户后台收到用户支付单，调用微信支付统一下单接口。参见【统一下单API】。<br>步骤3：统一下单接口返回正常的prepay_id，再按签名规范重新生成签名后，将数据传输给APP。参与签名的字段名为appId，partnerId，prepayId，nonceStr，timeStamp，package。注意：package的值格式为Sign=WXPay<br>步骤4：商户APP调起微信支付。api参见本章节【app端开发步骤说明】<br>步骤5：商户后台接收支付通知。api参见【支付结果通知API】<br>步骤6：商户后台查询支付结果。，api参见【查询订单API】</p>
<p>##APP 开发步骤</p>
<ol>
<li>设置appid</li>
</ol>
<p>商户在微信开放平台申请开发APP应用后，微信开放平台会生成APP的唯一标识APPID。在Xcode中打开项目，设置项目属性中的URL Schemes为您的APPID。<br><img src="http://ac-1qdtcf4c.clouddn.com/ff800196a5ae07e2.png" alt=""></p>
<p>2.注册APPID</p>
<p>商户APP工程中引入微信lib库和头文件，调用API前，需要先向微信注册您的APPID，代码如下：<br>[WXApi registerApp：@”wxd930ea5d5a258f4f” withDescription：@”demo 2.0”];</p>
<p>3、调起支付<br>商户服务器生成支付订单，先调用【统一下单API】生成预付单，获取到prepay_id后将参数再次签名传输给APP发起支付。以下是调起微信支付的关键代码：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PayReq *request = [[[PayReq alloc] init] autorelease]<span class="comment">;</span></span><br><span class="line">request.partnerId = @"<span class="number">10000100</span>"<span class="comment">;</span></span><br><span class="line">request.prepayId= @"<span class="number">1101000000140</span>415649af9fc314aa427"<span class="comment">;</span></span><br><span class="line">request.package = @"Sign=WXPay"<span class="comment">;</span></span><br><span class="line">request.nonceStr= @"a<span class="number">462b76e74</span>36e98e0ed<span class="number">6e13c64b4</span>fd1c"<span class="comment">;</span></span><br><span class="line">request.timeStamp= @"<span class="number">1397527777</span>"<span class="comment">;</span></span><br><span class="line">request.sign= @"<span class="number">582282D72</span>DD2B03AD<span class="number">892830965</span>F428CB<span class="number">16E7A256</span>"<span class="comment">;</span></span><br><span class="line">[WXApi sendReq：request]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>4、支付结果回调<br>照微信SDK Sample，在类实现onResp函数，支付完成后，微信APP会返回到商户APP并回调onResp函数，开发者需要在该函数中接收通知，判断返回错误码，如果支付成功则去后台查询支付结果再展示用户实际支付结果。注意    一定不能以客户端返回作为用户支付的结果，应以服务器端的接收的支付通知或查询API返回的结果为准。代码示例如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   -(<span class="keyword">void</span>)onResp：(BaseResp*)resp&#123;        </span><br><span class="line"><span class="keyword">if</span> ([respisKindOfClass：[PayRespclass]])&#123;</span><br><span class="line">    PayResp*response=(PayResp*)resp;</span><br><span class="line">    <span class="keyword">switch</span>(response<span class="variable">.errCode</span>)&#123;</span><br><span class="line">        caseWXSuccess：</span><br><span class="line">                 			<span class="comment">//服务器端查询支付通知或查询API返回的结果再提示成功</span></span><br><span class="line">                 			<span class="built_in">NSlog</span>(<span class="string">@"支付成功"</span>);</span><br><span class="line">                 	<span class="keyword">break</span>;</span><br><span class="line">                 	<span class="keyword">default</span>：</span><br><span class="line">                 	<span class="built_in">NSlog</span>(<span class="string">@"支付失败，retcode=%d"</span>,resp<span class="variable">.errCode</span>);</span><br><span class="line">                 	<span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>回调中errCode值列表:</p>
<table>
<thead>
<tr>
<th>名  称</th>
<th style="text-align:right">描述</th>
<th style="text-align:center">解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:right">成功</td>
<td style="text-align:center">展示成功页面</td>
</tr>
<tr>
<td>-1</td>
<td style="text-align:right">错误</td>
<td style="text-align:center">可能的原因：签名错误，未注册appid，项目设置appid不正确，注册的appid与设置的不匹配，其他异常等</td>
</tr>
<tr>
<td>-2</td>
<td style="text-align:right">用户取消</td>
<td style="text-align:center">无需处理。发生场景：用户中途取消支付，返回商户app</td>
</tr>
</tbody>
</table>
<p>微信支付业务流程与支付宝大致相同，但是有一点区别就是:</p>
<p>微信支付需要先生成预支付订单.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/21/微信支付/" data-id="cijmj82jq0002nj0ef6nhagqz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-支付宝支付" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/21/支付宝支付/" class="article-date">
  <time datetime="2015-12-21T00:44:23.000Z" itemprop="datePublished">2015-12-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/21/支付宝支付/">支付宝支付</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#支付宝支付</p>
<p>下载：<br><a href="https://b.alipay.com/order/productDetail.htm?productId=2013080604609654&amp;tabId=4#ps-tabinfo-hash" target="_blank" rel="external">https://b.alipay.com/order/productDetail.htm?productId=2013080604609654&amp;tabId=4#ps-tabinfo-hash</a></p>
<p>文档：<br>压缩包里应该有两个压缩文档<br>&lt;支付宝钱包支付接口开发包2.0标准版&gt;<br>&lt;支付宝钱包支付接口开发包2.0标准版接入与使用规则&gt;<br>iOS 相关内容可以直接看第一个文档，第二个文档名字和里面写的不一样，内容其实是一个附录;<br>文档里面多个平台都涉及到了，内容有些杂乱。</p>
<p>下面我用几幅图来给大家展示一下客户端调起支付的过程：</p>
<p>1.买家在手机应用中购买商品或者是服务<br><img src="http://ac-1qdtcf4c.clouddn.com/257d752d2f3fc78f.png" alt=""></p>
<p>2.买家选择支付方式<br><img src="http://ac-1qdtcf4c.clouddn.com/f76d425211867ed8.png" alt=""></p>
<p>3.进入支付宝收银台进行付款<br><img src="http://ac-1qdtcf4c.clouddn.com/8b809e52fe258fb9.png" alt=""></p>
<p>4.支付成功<br><img src="http://ac-1qdtcf4c.clouddn.com/25463dc99a5fa5b8.png" alt=""></p>
<p>5.交易完成，买家可以查看交易信息<br><img src="http://ac-1qdtcf4c.clouddn.com/7174ef6c1f58a9e9.png" alt=""></p>
<p>在调用支付之前,将商品数据信息生成待签名的字符串,信息包括:</p>
<p>{</p>
<p>}</p>
<p>如何声明密钥请看文档：</p>
<p><a href="http://doc.open.alipay.com/doc2/detail?treeId=58&amp;articleId=103242&amp;docType=1" target="_blank" rel="external">http://doc.open.alipay.com/doc2/detail?treeId=58&amp;articleId=103242&amp;docType=1</a></p>
<p>1.安装OpenSSL工具</p>
<p>2.RSA私钥及公钥生成</p>
<p>RSA加密算法除了可以加解密外，还可以用来做签名校验。简单的说，RSA会生成一个私钥和一个公钥，私钥你应该独自保管，公钥你可以分发出去。做签名验证时，你可以用私钥对需要传输的数据做签名加密，生成一个签名值，之后分发数据，接收方通过公钥对签名值做校验，如果一致则认为数据无篡改.</p>
<p>具体到支付宝使用RSA做签名验证，就是在生产订单的时候，需要使用私钥生成签名值；在处理返回的支付结果时，需要使用公钥验证返回结果是否被篡改了。具体需要对哪些值，怎么样生成签名，对哪些值做签名验证，可以在第一个文档中找找，后面我会简单提一下，但还是以文档或实践为准吧。</p>
<p><strong>订单签名：</strong></p>
<p>上面说了，订单签名应该使用私钥，但是把私钥放在app里其实是不安全的，因为你的app是分发到用户手里的，私钥应该放在你的手里，分发出去的应该是公钥。所以私钥最好是放在自己的服务器上，订单加密这个工作放在服务器来做，服务器将包含签名的订单信息返回给app，app再通过SDK发送给支付宝，这样会更安全一些；而且服务器也能掌握所有的订单状况。</p>
<p>如果你非要将私钥集成到app里，那可以参考SDK的demo，因为这个demo就是在app本地通过私钥做的订单签名。</p>
<p><strong>支付结果签名验证</strong></p>
<p>上面的回调block提到了返回的内容，返回的支付结果中的result字段里是带有订单信息和签名信息的，所以签名验证就是需要这个字段的值。<br>文档中有一个这个字段的例子，实际结果没有换行，我换一行便于阅读:</p>
<blockquote>
<p>partner=”2088101568358171”&amp;seller_id=”xxx@alipay.com”&amp;out_trade_no=”0819145412-6177”&amp;subject= &amp;sign_type=”RSA” &amp;sign=”hkFZr+zE9499nuqDNLZEF7W75RFFPsly876QuRSeN8WMaUgcdR00IKy5ZyBJ4eldhoJ/2zghqrD4E2G2mNjs3aE”</p>
</blockquote>
<p>这个签名当中分为三部分</p>
<p>第一部分是订单信息，每个字段的具体含义可以再文档里找；<br>中间sign_type 是签名所用的算法，文档中提到，目前只是支持RSA;<br>最后的sign就是签名值。</p>
<p>验证的步骤如下:</p>
<p>首先把订单信息和签名值分别提取出来(SDK中并没有给进行处理)</p>
<pre><code>订单信息就是sign_type的连字符&amp;之前的所有字符串

签名值是sign后面双引导的内容，注意签名的结尾也是 = ，所以不要用split字符串的方法提取
</code></pre><p><strong>支付SDK</strong></p>
<p>如果只需要发送订单和处理支付返回结果，只需要添加AlipaySDK.bundle 和 Alipay.framework 就行了。</p>
<p>发送订单的方法:</p>
<ul>
<li>(void)payOrder:(NSString <em>)orderStr fromScheme:(NSString </em>)schemeStr<br>callback:(CompletionBlock)completionBlock</li>
</ul>
<p>此时需要注意：</p>
<p>如果手机内没有安装支付宝的app，会直接展现支付宝web支付页面，通过callback返回支付结果；</p>
<p>如果手机内安装了支付宝的app，会跳转到支付宝的app支付，然后通过openUrl的回调返回支付结果.</p>
<p>支付宝的SDK只给了一个处理返回结果的方法，而不会像其他的第三方SDK提供一个处理openUrl的方法，所以你需要通过demo或者在第二个文档里找到处理openUrl的方式:</p>
<p>if ([url.host isEqualToString:@”safepay”]) {<br>[[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) {<br>}]; }</p>
<p>SDK也提供了一个处理openUrl返回结果的方法</p>
<ul>
<li>(void)processOrderWithPaymentResult:(NSURL *)resultUrl standbyCallback:(CompletionBlock)completionBlock;</li>
</ul>
<p>两个回调block都统一定义为typedef void(^CompletionBlock)(NSDictionary *resultDic);<br>返回了一个字典，但是SDK里完全没有提示有哪些Key.</p>
<p>我们来看一下resultStatus 状态码分别代码什么意思，这个是在文档中没有的</p>
<p>9000 订单支付成功</p>
<p>8000 正在处理中</p>
<p>4000 订单支付失败</p>
<p>6001 用户中途取消</p>
<p>6002 网络连接出错</p>
<p>memo 提示信息, 比如说状态码为 6001时，memo就是“用户中途取消的意思”,但是我们在开发中绝对不能依赖于这个信息,如果未安装支付宝的app，采用网页支付时，取消时状态码是 6001，但这个memo是空的。</p>
<p>result 订单信息,以及签名验证信息.如果你不想做签名验证，这个字段可以忽略不计了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/21/支付宝支付/" data-id="cijmj82jo0001nj0eoofhy0xf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-什么是-HTTPS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/14/什么是-HTTPS/" class="article-date">
  <time datetime="2015-12-14T08:47:27.000Z" itemprop="datePublished">2015-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/14/什么是-HTTPS/">什么是 HTTPS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们先来看一下百度百科的解释：<br>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司(Netscape)进行，并内置于其浏览器Netscape Navigator中，提供了身份验证与加密通讯方法</p>
<p>简单来讲就是一句话： HTTP + SSL = HTTPS</p>
<p>那 HTTP 和 HTTPS 二者之间到底有什么区别呢 ？<br>HTTP(超文本传输协议)协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。<br>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<p>HTTPS和HTTP的区别主要为以下四点：<br>一、https协议需要到ca申请证书，一般免费证书很少，需要交费。<br>二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。<br>三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<p>那现在肯定有些人对SSL好奇咯，我们现在看看 SSL能提供一些什么服务呢 ？</p>
<p>SSL协议提供的服务主要有哪些<br>1）认证用户和服务器，确保数据发送到正确的客户机和服务器<br>2）加密数据以防止数据中途被窃取<br>3）维护数据的完整性，确保数据在传输过程中不被改变。<br>SSL协议的工作流程<br>服务器认证阶段：<br>1）客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；<br>2）服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；<br>3）客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；<br>4）服务器恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。</p>
<p>那 现在我们来看一下 HTTPS 在使用时  我们在iOS这一块需要做一些什么事情呢 ？</p>
<p>实现支持HTTPS<br>首先，需要明确你使用HTTP/HTTPS的用途，因为OSX和iOS平台提供了多种API，来支持不同的用途，官方文档《Making HTTP and HTTPS Requests》有详细的说明，而文档《HTTPS Server Trust Evaluation》则详细讲解了HTTPS验证相关知识，这里就不多说了。本文主要讲解我们最常用的NSURLConnection支持HTTPS的实现（NSURLSession的实现方法类似，只是要求授权证明的回调不一样而已），以及怎么样使用AFNetworking这个非常流行的第三方库来支持HTTPS。本文假设你对HTTP以及NSURLConnection的接口有了足够的了解。<br>验证证书的API<br>相关的Api在Security Framework中，验证流程如下：<br>1). 第一步，先获取需要验证的信任对象(Trust Object)。这个Trust Object在不同的应用场景下获取的方式都不一样，对于NSURLConnection来说，是从delegate方法-connection:willSendRequestForAuthenticationChallenge:回调回来的参数challenge中获取([challenge.protectionSpace serverTrust])。<br>2). 使用系统默认验证方式验证Trust Object。SecTrustEvaluate会根据Trust Object的验证策略，一级一级往上，验证证书链上每一级数字签名的有效性（上一部分有讲解），从而评估证书的有效性。<br>3). 如第二步验证通过了，一般的安全要求下，就可以直接验证通过，进入到下一步：使用Trust Object生成一份凭证([NSURLCredential credentialForTrust:serverTrust])，传入challenge的sender中([challenge.sender useCredential:cred forAuthenticationChallenge:challenge])处理，建立连接。<br>4). 假如有更强的安全要求，可以继续对Trust Object进行更严格的验证。常用的方式是在本地导入证书，验证Trust Object与导入的证书是否匹配。更多的方法可以查看Enforcing Stricter Server Trust Evaluation，这一部分在讲解AFNetworking源码中会讲解到。<br>5). 假如验证失败，取消此次Challenge-Response Authentication验证流程，拒绝连接请求。<br>ps: 假如是自建证书的，则会跳过第二步，使用第三部进行验证，因为自建证书的根CA的数字签名未在操作系统的信任列表中。<br>iOS授权验证的API和流程大概了解了，下面，我们看看在NSURLConnection中的代码实现：<br>使用NSURLConnection支持HTTPS的实现<br>// Now start the connection<br>NSURL * httpsURL = [NSURL URLWithString:@”<a href="https://www.google.com" target="_blank" rel="external">https://www.google.com</a>“];<br>self.connection = [NSURLConnection connectionWithRequest:[NSURLRequest requestWithURL:httpsURL] delegate:self];</p>
<p>//回调</p>
<ul>
<li><p>(void)connection:(NSURLConnection <em>)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge </em>)challenge {<br>  //1)获取trust object<br>  SecTrustRef trust = challenge.protectionSpace.serverTrust;<br>  SecTrustResultType result;</p>
<p>  //2)SecTrustEvaluate对trust进行验证<br>  OSStatus status = SecTrustEvaluate(trust, &amp;result);<br>  if (status == errSecSuccess &amp;&amp;</p>
<pre><code>(result == kSecTrustResultProceed ||
result == kSecTrustResultUnspecified)) {

//3)验证成功，生成NSURLCredential凭证cred，告知challenge的sender使用这个凭证来继续连接
NSURLCredential *cred = [NSURLCredential credentialForTrust:trust];
[challenge.sender useCredential:cred forAuthenticationChallenge:challenge];
</code></pre><p>  } else {</p>
<pre><code>//5)验证失败，取消这次验证流程
[challenge.sender cancelAuthenticationChallenge:challenge];
</code></pre><p>}<br>}<br>上面是代码是通过系统默认验证流程来验证证书的。假如我们是自建证书的呢？这样Trust Object里面服务器的证书因为不是可信任的CA签发的，所以直接使用SecTrustEvaluate进行验证是不会成功。又或者，即使服务器返回的证书是信任CA签发的，又如何确定这证书就是我们想要的特定证书？这就需要先在本地导入证书，设置成需要验证的Anchor Certificate(就是根证书)，再调用SecTrustEvaluate来验证。代码如下<br>//先导入证书<br>NSString <em> cerPath = …; //证书的路径<br>NSData </em> cerData = [NSData dataWithContentsOfFile:cerPath];<br>SecCertificateRef certificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)(cerData));<br>self.trustedCertificates = @[CFBridgingRelease(certificate)];<br>//回调</p>
</li>
<li><p>(void)connection:(NSURLConnection <em>)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge </em>)challenge {<br>  //1)获取trust object<br>  SecTrustRef trust = challenge.protectionSpace.serverTrust;<br>  SecTrustResultType result;<br>  //注意：这里将之前导入的证书设置成下面验证的Trust Object的anchor certificate<br>  SecTrustSetAnchorCertificates(trust, (__bridge CFArrayRef)self.trustedCertificates);<br>  //2)SecTrustEvaluate会查找前面SecTrustSetAnchorCertificates设置的证书或者系统默认提供的证书，对trust进行验证<br>  OSStatus status = SecTrustEvaluate(trust, &amp;result);<br>  if (status == errSecSuccess &amp;&amp;</p>
<pre><code>(result == kSecTrustResultProceed ||
result == kSecTrustResultUnspecified)) {

//3)验证成功，生成NSURLCredential凭证cred，告知challenge的sender使用这个凭证来继续连接
NSURLCredential *cred = [NSURLCredential credentialForTrust:trust];
[challenge.sender useCredential:cred forAuthenticationChallenge:challenge];
</code></pre><p>  } else {</p>
<pre><code>//5)验证失败，取消这次验证流程
[challenge.sender cancelAuthenticationChallenge:challenge];
</code></pre><p>}<br>}<br>建议采用本地导入证书的方式验证证书，来保证足够的安全性。更多的验证方法，请查看官方文档《HTTPS Server Trust Evaluation》</p>
</li>
</ul>
<p>那 对于熟悉网络请求的同学 对于AFNetworking肯定不会陌生了，它是使用的时候是怎么配置HTTPS的呢？</p>
<p>AFNetworking上配置对HTTPS的支持非常简单：</p>
<p>NSURL <em> url = [NSURL URLWithString:@”<a href="https://www.google.com" target="_blank" rel="external">https://www.google.com</a>“];<br>AFHTTPRequestOperationManager </em> requestOperationManager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:url];<br>dispatch_queue_t requestQueue = dispatch_create_serial_queue_for_name(“kRequestCompletionQueue”);<br>requestOperationManager.completionQueue = requestQueue;<br>AFSecurityPolicy <em> securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];<br>//allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO<br>//如果是需要验证自建证书，需要设置为YES<br>securityPolicy.allowInvalidCertificates = YES;<br>//validatesDomainName 是否需要验证域名，默认为YES；<br>//假如证书的域名与你请求的域名不一致，需把该项设置为NO<br>//主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名</em>.google.com，但这个还是比较贵的。<br>securityPolicy.validatesDomainName = NO;<br>//validatesCertificateChain 是否验证整个证书链，默认为YES<br>//设置为YES，会将服务器返回的Trust Object上的证书链与本地导入的证书进行对比，这就意味着，假如你的证书链是这样的：<br>//GeoTrust Global CA<br>//    Google Internet Authority G2<br>//        <em>.google.com<br>//那么，除了导入</em>.google.com之外，还需要导入证书链上所有的CA证书（GeoTrust Global CA, Google Internet Authority G2）；<br>//如是自建证书的时候，可以设置为YES，增强安全性；假如是信任的CA所签发的证书，则建议关闭该验证；<br>securityPolicy.validatesCertificateChain = NO;<br>requestOperationManager.securityPolicy = securityPolicy;<br>这就是AFNetworking的支持HTTPS的主要配置说明，AFHTTPSessionManager与之基本一致，就不重复了。</p>
<p>因为HTTPS相比于HTTP来说，会有一些性能上的劣势，但是相对比安全性，就是小巫见大巫了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/14/什么是-HTTPS/" data-id="cijmj82jt0004nj0e9v4pnsu7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-十款经典的markdown编辑器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/14/十款经典的markdown编辑器/" class="article-date">
  <time datetime="2015-12-14T08:36:41.000Z" itemprop="datePublished">2015-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/14/十款经典的markdown编辑器/">十款经典的markdown编辑器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>摘要：作为一个开源人，如果你不会使用Markdown语法，那你就OUT了！Markdown 是 2004 年由 John Gruberis 设计和开发的纯文本格式的语法，非常的简单实用。<br>作为一个开源人，如果你不会使用Markdown语法，那你就OUT了！Markdown 是 2004 年由 John Gruberis 设计和开发的纯文本格式的语法，非常的简单实用。 CSDN CODE平台的 帮助文档、项目README文件、文档项目甚至包括ISSUES和项目评论等都是支持Markdown语法的！</p>
<p>1.MarkdownPad </p>
<p>用户可以通过键盘快捷键和工具栏按钮来使用或者移除 Markdown 格式。MarkdownPad左右栏的分割方式令用户可以实时看到 HTML 格式的 Markdown 文档。<br>下载地址： <a href="http://markdownpad.com/" target="_blank" rel="external">http://markdownpad.com/</a></p>
<p>2.ReText</p>
<p>ReText 是一个使用 Markdown 语法和 reStructuredText (reST) 结构的文本编辑器，编辑的内容支持导出到 PDF、ODT 和 HTML 以及纯文本，支持即时预览、网页生成以及 HTML 语法高亮、全屏模式，可导出文件到 Google Docs 等。<br>下载地址： <a href="http://sourceforge.net/p/retext/home/ReText/" target="_blank" rel="external">http://sourceforge.net/p/retext/home/ReText/</a></p>
<p>3.WMD</p>
<p>WMD (wmd-editor)是一个简单轻量级的HTML编辑器，使用的是 Markdown 文本格式数据，适合用来做博客评论、发帖和一些基本的内容发布系统，支持流行的各种浏览器。<br>下载地址： <a href="http://code.google.com/p/wmd/" target="_blank" rel="external">http://code.google.com/p/wmd/</a></p>
<p>4.Mou</p>
<p>Mou 是 Mac下杰出的 Markdown 编辑器，提供语法高亮、在线预览、同步滚动、全屏模式，支持自定保存、自动匹配，允许自定义主题，支持 CSS，HTML 和 PDF 导出等。<br>下载地址： <a href="http://mouapp.com/" target="_blank" rel="external">http://mouapp.com/</a></p>
<p>5.EpicEditor</p>
<p>EpicEditor 是一个可嵌入式的 JavaScript Markdown 编辑器，提供全屏编辑、在线预览、自动保存草稿和离线编辑支持。对开发者提供可可靠的 API 做风格设置。<br>下载地址： <a href="http://epiceditor.com/" target="_blank" rel="external">http://epiceditor.com/</a></p>
<p>6.CuteMarkEd</p>
<p>CuteMarkEd 是一个 Markdown 编辑器，提供实时 HTML 预览、数学表达式和源码高亮。<br>下载地址：<a href="http://cloose.github.io/CuteMarkEd" target="_blank" rel="external">http://cloose.github.io/CuteMarkEd</a></p>
<p>7.MarkPad</p>
<p>MarkPad 是款开源的 Markdown 编辑器，与 Window 8 风格和谐友好的界面，可以直接在你的博客或者 GitHub 中打开、保存文档，直接将图片粘贴到 Markdown 文档中。</p>
<p>下载地址：<a href="http://code52.org/DownmarkerWPF/" target="_blank" rel="external">http://code52.org/DownmarkerWPF/</a></p>
<p>8.Haroopad</p>
<p>Haroopad 是一款覆盖三大主流桌面系统的编辑器，支持 Windows、Mac OS X 和 Linux。 主题样式丰富，语法标亮支持 54 种编程语言。该工具重点推荐 Ubuntu/Linux 用户使用，从此可以告别 gedit 加 Markdown 插件这种工作方式了。<br>下载地址： <a href="http://pad.haroopress.com/user.html" target="_blank" rel="external">http://pad.haroopress.com/user.html</a></p>
<p>9.MarkdownEditor</p>
<p>MarkdownEditor 是一款基于浏览器的 Markdown 文本编辑器，功能非常简单实用。<br>在线地址： <a href="http://jbt.github.io/markdown-editor" target="_blank" rel="external">http://jbt.github.io/markdown-editor</a></p>
<p>10.QMarkdowner</p>
<p>QMarkdowner是一款基于PyQt4的markdown编辑器，支持实时编辑与实时预览和全屏预览。</p>
<p>下载地址：<a href="https://github.com/dragondjf/QMarkdowner" target="_blank" rel="external">https://github.com/dragondjf/QMarkdowner</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/14/十款经典的markdown编辑器/" data-id="cijmj82js0003nj0ecm1dgtu0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS9-Bitcode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/14/iOS9-Bitcode/" class="article-date">
  <time datetime="2015-12-14T08:16:55.000Z" itemprop="datePublished">2015-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/14/iOS9-Bitcode/">iOS9 Bitcode</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###问题一 ：什么是 bit code<br>在App Distribution Guide – App Thinning (iOS, watchOS)一节中，找到了下面这样一个定义：<br>Bitcode is an intermediate representation of a compiled program. Apps you upload to iTunes Connect that contain bitcode will be compiled and linked on the App Store. Including bitcode will allow Apple to re-optimize your app binary in the future without the need to submit a new version of your app to the store.<br>bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。</p>
<p>在What’s New in Xcode-New Features in Xcode 7中，还有一段如下的描述<br>Bitcode. When you archive for submission to the App Store, Xcode will compile your app into an intermediate representation. The App Store will then compile the bitcode down into the 64 or 32 bit executables as necessary.<br>当我们提交程序到App store上时，Xcode会将程序编译为一个中间表现形式(bitcode)。然后App store会再将这个botcode编译为可执行的64位或32位程序。Xcode7默认会开启Bitcode。</p>
<p>###问题二 :可能存在的问题<br>用Xcode 7 上运行我们的工程，结果发现工程编译不过。看了下问题，报的是以下错误：<br>ld: ‘/Users/<strong>/Framework/SDKs/PolymerPay/Library/mobStat/lib</strong>SDK.a(**ForSDK.o)’ does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64<br>得到的信息是我们引入的一个第三方库不包含bitcode。</p>
<p>bit code配置<br>在上面的错误提示中，提到了如何处理我们遇到的问题：<br>You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64<br>对应这个问题我们有两种解决方案，要么让第三方库支持，要么关闭target的bitcode选项。<br>实际上在Xcode 7中，我们新建一个iOS程序时，bitcode选项默认是设置为YES的。我们可以在”Build Settings”-&gt;”Enable Bitcode”选项中看到这个设置。<br>但是还有一点，对应着三个平台 bitcode 是不一样的。对应iOS，bitcode是可选的。对于watchOS，bitcode是必须的。Mac OS不支持bitcode。</p>
<p>###还有一点需要注意：<br>在做静态库的时候，如果需要支持bitcode，请看下面链接<br><a href="http://stackoverflow.com/questions/31486232/how-do-i-xcodebuild-a-static-library-with-bitcode-enabled" target="_blank" rel="external">http://stackoverflow.com/questions/31486232/how-do-i-xcodebuild-a-static-library-with-bitcode-enabled</a></p>
<p><a href="http://blog.csdn.net/yjh4866/article/details/49156899" target="_blank" rel="external">http://blog.csdn.net/yjh4866/article/details/49156899</a></p>
<pre><code>  所以说，如果我们的工程需要支持bitcode，则必须要求所有的引入的第三方库都支持bitcode。否则就只能等着公司那些大哥大姐们啥时候提供一个新包给我们了。
了解了吧，bitcode就是这样一个东西，重复上面的那句话：bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/14/iOS9-Bitcode/" data-id="cijmj82jw0005nj0eassdymht" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HTTP服务端状态码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/14/HTTP服务端状态码/" class="article-date">
  <time datetime="2015-12-14T08:09:58.000Z" itemprop="datePublished">2015-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/14/HTTP服务端状态码/">HTTP服务端状态码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> HTTP错误是由HTTP请求，HTTP服务器或应用服务器的问题造成的。HTTP错误通过HTTP响应的状态码发送给请求客户端。<br>       404状态是常见的一种HTTP错误，表示找不到URL指定的资源。一共有五类的HTTP错误:<br>       信息性质的100级别 – 来自于HTTP服务器的信息，表示请求的处理将会继续，不过带有警告。<br>       成功的200级别 – 服务器处理了请求。每个200级别的状态都表示成功请求的不同结果。比如：204表示请求成功，不过没有向客户端返回负载。<br>       重定向需要的300级别 – 表示客户端必须执行某个动作才能继续请求，因为所需的资源已经移动了。URL加载系统的同步请求会自动处理重定向而无须通知代码。如果应用需要对重定向进行自定义处理，那么应该使用异步请求。<br>       客户端错误的400级别 – 表示客户端发出了服务器无法正确处理的错误信息。比如：未知的URL 或是不正确地HTTP头会导致这个范围内的错误。<br>       下游错误500级别 – 表示HTTP服务器与下游应用服务器之间出现了错误。比如，如果web服务器调用了JavaEE应用服务器，Servlet出现了NullPointerExceotion，那么客户端就会收到500级别的错误。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/14/HTTP服务端状态码/" data-id="cijmj82k00007nj0e7sxyfwm1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HTTP中的cookie" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/11/HTTP中的cookie/" class="article-date">
  <time datetime="2015-12-11T03:04:21.000Z" itemprop="datePublished">2015-12-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/11/HTTP中的cookie/">HTTP中的cookie</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#HTTP中的Cookie<br>       Cookie是HTTP协议在首个版本之后加入的一个重要组件。它向服务器提供了追踪会话状态的能力，同时又无需维持客户端和服务器之间的链接。在浏览客户端，Cookie值由服务器通过请求提供的，然后被放到随后的请求当中。由于设计Cookie的目的是追踪会话状态，因此他们都比较小，基本上是几十到几百字节。<br>       从服务器发送的Cookie有几个属性用于确定Cookie值，何时返回到服务器以及客户端应该保留Cookie的时间。这些属性有：<br>       name–  Cookie的名字，从同一DNS域返回所有Cookie名都是唯一的。只有name 和 value 这两个属性才会在后续的请求中发送给服务器。<br>       value– 由向服务器发送的下一请求返回的值<br>       domain – 后续请求在Cookie中包含的DNS域。比如，拥有域值.domain.com的Cookie不应该返回给.domain.com。如果省略到，那么客户端就会将URL的主机名当做是域.<br>       path – path限制发送给请求的Cookie都是针对指定的URL路径。<br>       Expitation Date - Cookie不再随请求发送的时间和日期，Cookie会在这个时间点从客户端删除<br>       Session Only - 指定Cookie是在当前浏览器会话时间内返回还是一直持续到过期日期，以二者之间先到的时间为准。<br>       Secure - 指定Cookie指定Cookie只会用在HTTPS连接而非HTTP连接<br>       Comment - 用于向用户说明Cookie目的的注释值<br>       Comment URL - URL值，向用户指定了一个HTML文档，用于说明Cookie的目的<br>       HTTP Only - 指示器，告诉客户端不要与JavaScript应用分享Cookie以防止跨站脚本攻击<br>       Version - Cookie遵循HTTP Cookie 规范版本.<br>       虽然不是浏览器，但是iOS程序依然可以在应用中使用Cookie.URL加载框架帮我们做了大量繁琐的工作以利用协议的这些特性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/11/HTTP中的cookie/" data-id="cijmj82k20008nj0e1j0mhsg2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/11/hello-world/" class="article-date">
  <time datetime="2015-12-11T02:32:57.000Z" itemprop="datePublished">2015-12-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/11/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/11/hello-world/" data-id="cijmj82jy0006nj0e6x0xiw8c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">9</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/12/21/银联支付/">银联支付</a>
          </li>
        
          <li>
            <a href="/2015/12/21/微信支付/">微信支付</a>
          </li>
        
          <li>
            <a href="/2015/12/21/支付宝支付/">支付宝支付</a>
          </li>
        
          <li>
            <a href="/2015/12/14/什么是-HTTPS/">什么是 HTTPS</a>
          </li>
        
          <li>
            <a href="/2015/12/14/十款经典的markdown编辑器/">十款经典的markdown编辑器</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>