<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>CocoaYang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="CocoaYang">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="CocoaYang">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CocoaYang">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="CocoaYang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">CocoaYang</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-什么是-HTTPS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/14/什么是-HTTPS/" class="article-date">
  <time datetime="2015-12-14T08:47:27.000Z" itemprop="datePublished">2015-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/14/什么是-HTTPS/">什么是 HTTPS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们先来看一下百度百科的解释：<br>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司(Netscape)进行，并内置于其浏览器Netscape Navigator中，提供了身份验证与加密通讯方法</p>
<p>简单来讲就是一句话： HTTP + SSL = HTTPS</p>
<p>那 HTTP 和 HTTPS 二者之间到底有什么区别呢 ？<br>HTTP(超文本传输协议)协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。<br>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<p>HTTPS和HTTP的区别主要为以下四点：<br>一、https协议需要到ca申请证书，一般免费证书很少，需要交费。<br>二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。<br>三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<p>那现在肯定有些人对SSL好奇咯，我们现在看看 SSL能提供一些什么服务呢 ？</p>
<p>SSL协议提供的服务主要有哪些<br>1）认证用户和服务器，确保数据发送到正确的客户机和服务器<br>2）加密数据以防止数据中途被窃取<br>3）维护数据的完整性，确保数据在传输过程中不被改变。<br>SSL协议的工作流程<br>服务器认证阶段：<br>1）客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；<br>2）服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；<br>3）客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；<br>4）服务器恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。</p>
<p>那 现在我们来看一下 HTTPS 在使用时  我们在iOS这一块需要做一些什么事情呢 ？</p>
<p>实现支持HTTPS<br>首先，需要明确你使用HTTP/HTTPS的用途，因为OSX和iOS平台提供了多种API，来支持不同的用途，官方文档《Making HTTP and HTTPS Requests》有详细的说明，而文档《HTTPS Server Trust Evaluation》则详细讲解了HTTPS验证相关知识，这里就不多说了。本文主要讲解我们最常用的NSURLConnection支持HTTPS的实现（NSURLSession的实现方法类似，只是要求授权证明的回调不一样而已），以及怎么样使用AFNetworking这个非常流行的第三方库来支持HTTPS。本文假设你对HTTP以及NSURLConnection的接口有了足够的了解。<br>验证证书的API<br>相关的Api在Security Framework中，验证流程如下：<br>1). 第一步，先获取需要验证的信任对象(Trust Object)。这个Trust Object在不同的应用场景下获取的方式都不一样，对于NSURLConnection来说，是从delegate方法-connection:willSendRequestForAuthenticationChallenge:回调回来的参数challenge中获取([challenge.protectionSpace serverTrust])。<br>2). 使用系统默认验证方式验证Trust Object。SecTrustEvaluate会根据Trust Object的验证策略，一级一级往上，验证证书链上每一级数字签名的有效性（上一部分有讲解），从而评估证书的有效性。<br>3). 如第二步验证通过了，一般的安全要求下，就可以直接验证通过，进入到下一步：使用Trust Object生成一份凭证([NSURLCredential credentialForTrust:serverTrust])，传入challenge的sender中([challenge.sender useCredential:cred forAuthenticationChallenge:challenge])处理，建立连接。<br>4). 假如有更强的安全要求，可以继续对Trust Object进行更严格的验证。常用的方式是在本地导入证书，验证Trust Object与导入的证书是否匹配。更多的方法可以查看Enforcing Stricter Server Trust Evaluation，这一部分在讲解AFNetworking源码中会讲解到。<br>5). 假如验证失败，取消此次Challenge-Response Authentication验证流程，拒绝连接请求。<br>ps: 假如是自建证书的，则会跳过第二步，使用第三部进行验证，因为自建证书的根CA的数字签名未在操作系统的信任列表中。<br>iOS授权验证的API和流程大概了解了，下面，我们看看在NSURLConnection中的代码实现：<br>使用NSURLConnection支持HTTPS的实现<br>// Now start the connection<br>NSURL * httpsURL = [NSURL URLWithString:@”<a href="https://www.google.com" target="_blank" rel="external">https://www.google.com</a>“];<br>self.connection = [NSURLConnection connectionWithRequest:[NSURLRequest requestWithURL:httpsURL] delegate:self];</p>
<p>//回调</p>
<ul>
<li><p>(void)connection:(NSURLConnection <em>)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge </em>)challenge {<br>  //1)获取trust object<br>  SecTrustRef trust = challenge.protectionSpace.serverTrust;<br>  SecTrustResultType result;</p>
<p>  //2)SecTrustEvaluate对trust进行验证<br>  OSStatus status = SecTrustEvaluate(trust, &amp;result);<br>  if (status == errSecSuccess &amp;&amp;</p>
<pre><code>(result == kSecTrustResultProceed ||
result == kSecTrustResultUnspecified)) {

//3)验证成功，生成NSURLCredential凭证cred，告知challenge的sender使用这个凭证来继续连接
NSURLCredential *cred = [NSURLCredential credentialForTrust:trust];
[challenge.sender useCredential:cred forAuthenticationChallenge:challenge];
</code></pre><p>  } else {</p>
<pre><code>//5)验证失败，取消这次验证流程
[challenge.sender cancelAuthenticationChallenge:challenge];
</code></pre><p>}<br>}<br>上面是代码是通过系统默认验证流程来验证证书的。假如我们是自建证书的呢？这样Trust Object里面服务器的证书因为不是可信任的CA签发的，所以直接使用SecTrustEvaluate进行验证是不会成功。又或者，即使服务器返回的证书是信任CA签发的，又如何确定这证书就是我们想要的特定证书？这就需要先在本地导入证书，设置成需要验证的Anchor Certificate(就是根证书)，再调用SecTrustEvaluate来验证。代码如下<br>//先导入证书<br>NSString <em> cerPath = …; //证书的路径<br>NSData </em> cerData = [NSData dataWithContentsOfFile:cerPath];<br>SecCertificateRef certificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)(cerData));<br>self.trustedCertificates = @[CFBridgingRelease(certificate)];<br>//回调</p>
</li>
<li><p>(void)connection:(NSURLConnection <em>)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge </em>)challenge {<br>  //1)获取trust object<br>  SecTrustRef trust = challenge.protectionSpace.serverTrust;<br>  SecTrustResultType result;<br>  //注意：这里将之前导入的证书设置成下面验证的Trust Object的anchor certificate<br>  SecTrustSetAnchorCertificates(trust, (__bridge CFArrayRef)self.trustedCertificates);<br>  //2)SecTrustEvaluate会查找前面SecTrustSetAnchorCertificates设置的证书或者系统默认提供的证书，对trust进行验证<br>  OSStatus status = SecTrustEvaluate(trust, &amp;result);<br>  if (status == errSecSuccess &amp;&amp;</p>
<pre><code>(result == kSecTrustResultProceed ||
result == kSecTrustResultUnspecified)) {

//3)验证成功，生成NSURLCredential凭证cred，告知challenge的sender使用这个凭证来继续连接
NSURLCredential *cred = [NSURLCredential credentialForTrust:trust];
[challenge.sender useCredential:cred forAuthenticationChallenge:challenge];
</code></pre><p>  } else {</p>
<pre><code>//5)验证失败，取消这次验证流程
[challenge.sender cancelAuthenticationChallenge:challenge];
</code></pre><p>}<br>}<br>建议采用本地导入证书的方式验证证书，来保证足够的安全性。更多的验证方法，请查看官方文档《HTTPS Server Trust Evaluation》</p>
</li>
</ul>
<p>那 对于熟悉网络请求的同学 对于AFNetworking肯定不会陌生了，它是使用的时候是怎么配置HTTPS的呢？</p>
<p>AFNetworking上配置对HTTPS的支持非常简单：</p>
<p>NSURL <em> url = [NSURL URLWithString:@”<a href="https://www.google.com" target="_blank" rel="external">https://www.google.com</a>“];<br>AFHTTPRequestOperationManager </em> requestOperationManager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:url];<br>dispatch_queue_t requestQueue = dispatch_create_serial_queue_for_name(“kRequestCompletionQueue”);<br>requestOperationManager.completionQueue = requestQueue;<br>AFSecurityPolicy <em> securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];<br>//allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO<br>//如果是需要验证自建证书，需要设置为YES<br>securityPolicy.allowInvalidCertificates = YES;<br>//validatesDomainName 是否需要验证域名，默认为YES；<br>//假如证书的域名与你请求的域名不一致，需把该项设置为NO<br>//主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名</em>.google.com，但这个还是比较贵的。<br>securityPolicy.validatesDomainName = NO;<br>//validatesCertificateChain 是否验证整个证书链，默认为YES<br>//设置为YES，会将服务器返回的Trust Object上的证书链与本地导入的证书进行对比，这就意味着，假如你的证书链是这样的：<br>//GeoTrust Global CA<br>//    Google Internet Authority G2<br>//        <em>.google.com<br>//那么，除了导入</em>.google.com之外，还需要导入证书链上所有的CA证书（GeoTrust Global CA, Google Internet Authority G2）；<br>//如是自建证书的时候，可以设置为YES，增强安全性；假如是信任的CA所签发的证书，则建议关闭该验证；<br>securityPolicy.validatesCertificateChain = NO;<br>requestOperationManager.securityPolicy = securityPolicy;<br>这就是AFNetworking的支持HTTPS的主要配置说明，AFHTTPSessionManager与之基本一致，就不重复了。</p>
<p>因为HTTPS相比于HTTP来说，会有一些性能上的劣势，但是相对比安全性，就是小巫见大巫了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/14/什么是-HTTPS/" data-id="cii5pyuhy0001z00ew6d7k6d9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-十款经典的markdown编辑器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/14/十款经典的markdown编辑器/" class="article-date">
  <time datetime="2015-12-14T08:36:41.000Z" itemprop="datePublished">2015-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/14/十款经典的markdown编辑器/">十款经典的markdown编辑器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>摘要：作为一个开源人，如果你不会使用Markdown语法，那你就OUT了！Markdown 是 2004 年由 John Gruberis 设计和开发的纯文本格式的语法，非常的简单实用。<br>作为一个开源人，如果你不会使用Markdown语法，那你就OUT了！Markdown 是 2004 年由 John Gruberis 设计和开发的纯文本格式的语法，非常的简单实用。 CSDN CODE平台的 帮助文档、项目README文件、文档项目甚至包括ISSUES和项目评论等都是支持Markdown语法的！</p>
<p>1.MarkdownPad </p>
<p>用户可以通过键盘快捷键和工具栏按钮来使用或者移除 Markdown 格式。MarkdownPad左右栏的分割方式令用户可以实时看到 HTML 格式的 Markdown 文档。<br>下载地址： <a href="http://markdownpad.com/" target="_blank" rel="external">http://markdownpad.com/</a></p>
<p>2.ReText</p>
<p>ReText 是一个使用 Markdown 语法和 reStructuredText (reST) 结构的文本编辑器，编辑的内容支持导出到 PDF、ODT 和 HTML 以及纯文本，支持即时预览、网页生成以及 HTML 语法高亮、全屏模式，可导出文件到 Google Docs 等。<br>下载地址： <a href="http://sourceforge.net/p/retext/home/ReText/" target="_blank" rel="external">http://sourceforge.net/p/retext/home/ReText/</a></p>
<p>3.WMD</p>
<p>WMD (wmd-editor)是一个简单轻量级的HTML编辑器，使用的是 Markdown 文本格式数据，适合用来做博客评论、发帖和一些基本的内容发布系统，支持流行的各种浏览器。<br>下载地址： <a href="http://code.google.com/p/wmd/" target="_blank" rel="external">http://code.google.com/p/wmd/</a></p>
<p>4.Mou</p>
<p>Mou 是 Mac下杰出的 Markdown 编辑器，提供语法高亮、在线预览、同步滚动、全屏模式，支持自定保存、自动匹配，允许自定义主题，支持 CSS，HTML 和 PDF 导出等。<br>下载地址： <a href="http://mouapp.com/" target="_blank" rel="external">http://mouapp.com/</a></p>
<p>5.EpicEditor</p>
<p>EpicEditor 是一个可嵌入式的 JavaScript Markdown 编辑器，提供全屏编辑、在线预览、自动保存草稿和离线编辑支持。对开发者提供可可靠的 API 做风格设置。<br>下载地址： <a href="http://epiceditor.com/" target="_blank" rel="external">http://epiceditor.com/</a></p>
<p>6.CuteMarkEd</p>
<p>CuteMarkEd 是一个 Markdown 编辑器，提供实时 HTML 预览、数学表达式和源码高亮。<br>下载地址：<a href="http://cloose.github.io/CuteMarkEd" target="_blank" rel="external">http://cloose.github.io/CuteMarkEd</a></p>
<p>7.MarkPad</p>
<p>MarkPad 是款开源的 Markdown 编辑器，与 Window 8 风格和谐友好的界面，可以直接在你的博客或者 GitHub 中打开、保存文档，直接将图片粘贴到 Markdown 文档中。</p>
<p>下载地址：<a href="http://code52.org/DownmarkerWPF/" target="_blank" rel="external">http://code52.org/DownmarkerWPF/</a></p>
<p>8.Haroopad</p>
<p>Haroopad 是一款覆盖三大主流桌面系统的编辑器，支持 Windows、Mac OS X 和 Linux。 主题样式丰富，语法标亮支持 54 种编程语言。该工具重点推荐 Ubuntu/Linux 用户使用，从此可以告别 gedit 加 Markdown 插件这种工作方式了。<br>下载地址： <a href="http://pad.haroopress.com/user.html" target="_blank" rel="external">http://pad.haroopress.com/user.html</a></p>
<p>9.MarkdownEditor</p>
<p>MarkdownEditor 是一款基于浏览器的 Markdown 文本编辑器，功能非常简单实用。<br>在线地址： <a href="http://jbt.github.io/markdown-editor" target="_blank" rel="external">http://jbt.github.io/markdown-editor</a></p>
<p>10.QMarkdowner</p>
<p>QMarkdowner是一款基于PyQt4的markdown编辑器，支持实时编辑与实时预览和全屏预览。</p>
<p>下载地址：<a href="https://github.com/dragondjf/QMarkdowner" target="_blank" rel="external">https://github.com/dragondjf/QMarkdowner</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/14/十款经典的markdown编辑器/" data-id="cii5pyuhf0000z00e6asgmj0x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS9-Bitcode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/14/iOS9-Bitcode/" class="article-date">
  <time datetime="2015-12-14T08:16:55.000Z" itemprop="datePublished">2015-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/14/iOS9-Bitcode/">iOS9 Bitcode</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###问题一 ：什么是 bit code<br>在App Distribution Guide – App Thinning (iOS, watchOS)一节中，找到了下面这样一个定义：<br>Bitcode is an intermediate representation of a compiled program. Apps you upload to iTunes Connect that contain bitcode will be compiled and linked on the App Store. Including bitcode will allow Apple to re-optimize your app binary in the future without the need to submit a new version of your app to the store.<br>bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。</p>
<p>在What’s New in Xcode-New Features in Xcode 7中，还有一段如下的描述<br>Bitcode. When you archive for submission to the App Store, Xcode will compile your app into an intermediate representation. The App Store will then compile the bitcode down into the 64 or 32 bit executables as necessary.<br>当我们提交程序到App store上时，Xcode会将程序编译为一个中间表现形式(bitcode)。然后App store会再将这个botcode编译为可执行的64位或32位程序。Xcode7默认会开启Bitcode。</p>
<p>###问题二 :可能存在的问题<br>用Xcode 7 上运行我们的工程，结果发现工程编译不过。看了下问题，报的是以下错误：<br>ld: ‘/Users/<strong>/Framework/SDKs/PolymerPay/Library/mobStat/lib</strong>SDK.a(**ForSDK.o)’ does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64<br>得到的信息是我们引入的一个第三方库不包含bitcode。</p>
<p>bit code配置<br>在上面的错误提示中，提到了如何处理我们遇到的问题：<br>You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64<br>对应这个问题我们有两种解决方案，要么让第三方库支持，要么关闭target的bitcode选项。<br>实际上在Xcode 7中，我们新建一个iOS程序时，bitcode选项默认是设置为YES的。我们可以在”Build Settings”-&gt;”Enable Bitcode”选项中看到这个设置。<br>但是还有一点，对应着三个平台 bitcode 是不一样的。对应iOS，bitcode是可选的。对于watchOS，bitcode是必须的。Mac OS不支持bitcode。</p>
<p>###还有一点需要注意：<br>在做静态库的时候，如果需要支持bitcode，请看下面链接<br><a href="http://stackoverflow.com/questions/31486232/how-do-i-xcodebuild-a-static-library-with-bitcode-enabled" target="_blank" rel="external">http://stackoverflow.com/questions/31486232/how-do-i-xcodebuild-a-static-library-with-bitcode-enabled</a></p>
<p><a href="http://blog.csdn.net/yjh4866/article/details/49156899" target="_blank" rel="external">http://blog.csdn.net/yjh4866/article/details/49156899</a></p>
<pre><code>  所以说，如果我们的工程需要支持bitcode，则必须要求所有的引入的第三方库都支持bitcode。否则就只能等着公司那些大哥大姐们啥时候提供一个新包给我们了。
了解了吧，bitcode就是这样一个东西，重复上面的那句话：bitcode是被编译程序的一种中间形式的代码。包含bitcode配置的程序将会在App store上被编译和链接。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/14/iOS9-Bitcode/" data-id="cii5pyui20002z00eg6bkeiuj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HTTP服务端状态码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/14/HTTP服务端状态码/" class="article-date">
  <time datetime="2015-12-14T08:09:58.000Z" itemprop="datePublished">2015-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/14/HTTP服务端状态码/">HTTP服务端状态码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> HTTP错误是由HTTP请求，HTTP服务器或应用服务器的问题造成的。HTTP错误通过HTTP响应的状态码发送给请求客户端。<br>       404状态是常见的一种HTTP错误，表示找不到URL指定的资源。一共有五类的HTTP错误:<br>       信息性质的100级别 – 来自于HTTP服务器的信息，表示请求的处理将会继续，不过带有警告。<br>       成功的200级别 – 服务器处理了请求。每个200级别的状态都表示成功请求的不同结果。比如：204表示请求成功，不过没有向客户端返回负载。<br>       重定向需要的300级别 – 表示客户端必须执行某个动作才能继续请求，因为所需的资源已经移动了。URL加载系统的同步请求会自动处理重定向而无须通知代码。如果应用需要对重定向进行自定义处理，那么应该使用异步请求。<br>       客户端错误的400级别 – 表示客户端发出了服务器无法正确处理的错误信息。比如：未知的URL 或是不正确地HTTP头会导致这个范围内的错误。<br>       下游错误500级别 – 表示HTTP服务器与下游应用服务器之间出现了错误。比如，如果web服务器调用了JavaEE应用服务器，Servlet出现了NullPointerExceotion，那么客户端就会收到500级别的错误。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/14/HTTP服务端状态码/" data-id="cii5pyui70004z00e1bjb2uoe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HTTP中的cookie" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/11/HTTP中的cookie/" class="article-date">
  <time datetime="2015-12-11T03:04:21.000Z" itemprop="datePublished">2015-12-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/11/HTTP中的cookie/">HTTP中的cookie</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#HTTP中的Cookie<br>       Cookie是HTTP协议在首个版本之后加入的一个重要组件。它向服务器提供了追踪会话状态的能力，同时又无需维持客户端和服务器之间的链接。在浏览客户端，Cookie值由服务器通过请求提供的，然后被放到随后的请求当中。由于设计Cookie的目的是追踪会话状态，因此他们都比较小，基本上是几十到几百字节。<br>       从服务器发送的Cookie有几个属性用于确定Cookie值，何时返回到服务器以及客户端应该保留Cookie的时间。这些属性有：<br>       name–  Cookie的名字，从同一DNS域返回所有Cookie名都是唯一的。只有name 和 value 这两个属性才会在后续的请求中发送给服务器。<br>       value– 由向服务器发送的下一请求返回的值<br>       domain – 后续请求在Cookie中包含的DNS域。比如，拥有域值.domain.com的Cookie不应该返回给.domain.com。如果省略到，那么客户端就会将URL的主机名当做是域.<br>       path – path限制发送给请求的Cookie都是针对指定的URL路径。<br>       Expitation Date - Cookie不再随请求发送的时间和日期，Cookie会在这个时间点从客户端删除<br>       Session Only - 指定Cookie是在当前浏览器会话时间内返回还是一直持续到过期日期，以二者之间先到的时间为准。<br>       Secure - 指定Cookie指定Cookie只会用在HTTPS连接而非HTTP连接<br>       Comment - 用于向用户说明Cookie目的的注释值<br>       Comment URL - URL值，向用户指定了一个HTML文档，用于说明Cookie的目的<br>       HTTP Only - 指示器，告诉客户端不要与JavaScript应用分享Cookie以防止跨站脚本攻击<br>       Version - Cookie遵循HTTP Cookie 规范版本.<br>       虽然不是浏览器，但是iOS程序依然可以在应用中使用Cookie.URL加载框架帮我们做了大量繁琐的工作以利用协议的这些特性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/11/HTTP中的cookie/" data-id="cii5pyuia0005z00enw466pzq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/11/hello-world/" class="article-date">
  <time datetime="2015-12-11T02:32:57.000Z" itemprop="datePublished">2015-12-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/11/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/11/hello-world/" data-id="cii5pyui50003z00ey6238gh0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">6</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/12/14/什么是-HTTPS/">什么是 HTTPS</a>
          </li>
        
          <li>
            <a href="/2015/12/14/十款经典的markdown编辑器/">十款经典的markdown编辑器</a>
          </li>
        
          <li>
            <a href="/2015/12/14/iOS9-Bitcode/">iOS9 Bitcode</a>
          </li>
        
          <li>
            <a href="/2015/12/14/HTTP服务端状态码/">HTTP服务端状态码</a>
          </li>
        
          <li>
            <a href="/2015/12/11/HTTP中的cookie/">HTTP中的cookie</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>